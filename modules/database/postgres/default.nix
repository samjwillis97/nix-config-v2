{
  config,
  pkgs,
  lib,
  ...
}:
with lib;
let
  cfg = config.modules.database.postgres;
  dockerEnabled = config.modules.virtualisation.docker.enable;
in
{
  options.modules.database.postgres = {
    enable = mkEnableOption "Enables Postgres";

    user = mkOption {
      type = types.str;
      default = "postgres";
      description = "The initial superuser to create.";
    };

    password = mkOption {
      type = types.str;
      default = "postgres";
      description = "The password for the initial superuser.";
    };

    databases = mkOption {
      type = types.listOf types.str;
      description = "The initial databases to create.";
    };
  };

  config = mkIf cfg.enable (mkMerge [
    {
      services.postgresql = {
        enable = true;
        enableTCPIP = true;
        initialScript = pkgs.writeText "postgresql-init-script" ''
          CREATE ROLE "${cfg.user}" WITH LOGIN SUPERUSER PASSWORD '${cfg.password}';
          ${lib.concatStringsSep "\n" (map (db:
            "CREATE DATABASE \"${db}\" WITH OWNER = \"${cfg.user}\";"
          ) cfg.databases)}
        '';
        authentication = ''
          # Generated by the easyPostgres module
          local all all peer
          host all all 127.0.0.1/32 scram-sha-256
          host all all ::1/128 scram-sha-256
          # Allow connections from the default Docker bridge network
          host all all 172.17.0.0/16 scram-sha-256
        '';
      };
    }
    (mkIf dockerEnabled {
      # By default, Docker containers run on the 172.17.0.0/16 subnet.
      # This rule allows containers on this network to connect to the host's PostgreSQL service.
      networking.firewall.allowedTCPPorts = [ 5432 ];
      networking.firewall.interfaces."docker0" = {
        allowedTCPPorts = [ 5432 ];
      };
    })
  ]);
}
